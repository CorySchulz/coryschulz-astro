/*!
 ████████╗ █████╗ ██████╗  ██████╗ ████████╗
 ╚══██╔══╝██╔══██╗██╔══██╗██╔═══██╗╚══██╔══╝
    ██║   ███████║██████╔╝██║   ██║   ██║   
    ██║   ██╔══██║██╔══██╗██║   ██║   ██║   
    ██║   ██║  ██║██║  ██║╚██████╔╝   ██║   
    ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝    ╚═╝   

   Tarot Carousel v0.1.0 - beta
   A highly customizable carousel with beautiful, physics-driven animations
   Copyright 2025 Magic Spells LLC

   This software is source-available but not open source.
   See LICENSES for usage tiers and commercial terms.

   Licensed under:
      - Magic Spells Non-Commercial License (free for personal use and non-revenue projects)
      - Magic Spells Commercial License (for commercial use by entities under $1M revenue)
      - Magic Spells Enterprise License (for all use by entities with $1M+ revenue)

     Author: Cory Schulz
    Website: https://www.magicspells.io/tarot
       Repo: https://github.com/magic-spells/tarot
     Issues: https://github.com/magic-spells/tarot/issues
   Licenses: https://www.magicspells.io/licenses
*/
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("@magic-spells/tarot")):"function"==typeof define&&define.amd?define(["@magic-spells/tarot"],t):(e="undefined"!=typeof globalThis?globalThis:e||self).SpotlightEffect=t(e.Tarot)}(this,(function(e){"use strict";class SpotlightEffect extends e.TarotEffect{static effectName="spotlight";static rules={min_slideWidth:1,max_slideWidth:1/0,min_slidesPerView:1,max_slidesPerView:1/0,loopBuffer:{left:1,right:1}};constructor(e){super(e);const t=this;t.sideScale=.9,t.sideOpacity=.5,t.blurValue=7,t.init()}applyFarLeft(e,t,i){const s=this,r=i.slide;e.leftWidthTrimmed=r-r*s.sideScale,e.style.transformOrigin="center left",e._scaleTransform=`scale(${s.sideScale})`,e.style.opacity=s.sideOpacity,e.style.filter=`blur(${s.blurValue}px)`}applyNearLeft(e,t,i){const s=this;t>.999&&(t=1),t<.005&&(t=0);const r=t*t*(3-2*t),l=s.sideScale+(1-s.sideScale)*r,n=Math.min(2*r,1),a=s.sideOpacity+(1-s.sideOpacity)*n,o=s.blurValue*(1-n),c=i.slide;e.leftWidthTrimmed=c-c*l,e.style.transformOrigin="center left",e._scaleTransform=`scale(${l})`,e.style.opacity=a,e.style.filter=`blur(${o}px)`}applyCenterSpotlight(e,t){e.style.transformOrigin="center",e._scaleTransform="scale(1)",e.style.opacity=1,e.style.filter="blur(0px)"}applyNearRight(e,t,i){const s=this;t>.999&&(t=1),t<.005&&(t=0);const r=t*t*(3-2*t),l=1+(s.sideScale-1)*r,n=r<.5?0:2*(r-.5),a=1+(s.sideOpacity-1)*n,o=s.blurValue*n,c=i.slide;e.rightWidthTrimmed=c-c*l,e.style.transformOrigin="center right",e._scaleTransform=`scale(${l})`,e.style.opacity=a,e.style.filter=`blur(${o}px)`}applyFarRight(e,t,i){const s=this,r=i.slide;e.rightWidthTrimmed=r-r*s.sideScale,e.style.transformOrigin="center right",e._scaleTransform=`scale(${s.sideScale})`,e.style.opacity=s.sideOpacity,e.style.filter=`blur(${s.blurValue}px)`}applyHidden(e,t){const i=this,s=t.slide;e.rightWidthTrimmed=s-s*i.sideScale,e.style.transformOrigin="center right",e._scaleTransform=`scale(${i.sideScale})`,e.style.opacity=i.sideOpacity,e.style.filter=`blur(${i.blurValue}px)`}render(e,t){const i=this,{slides:s,widths:r,animation:l}=e;i.renderSlideWidth(r.slide),i.renderTrackPosition(l);for(let e=0,l=s.length;e<l;e++){const l=s[e];l.leftWidthTrimmed=0,l.rightWidthTrimmed=0,l._scaleTransform="",l.renderPosition=l.trackPosition,l.style.transition="none";const n=t.isSlideInRange(l,"L+","L1");if(n.isInRange){i.applyFarLeft(l,n.percent,r);continue}const a=t.isSlideInRange(l,"L1","CL1");if(a.isInRange){i.applyNearLeft(l,a.percent,r);continue}const o=t.isSlideInRange(l,"CL1","CR1");if(o.isInRange){i.applyCenterSpotlight(l,o.percent);continue}const c=t.isSlideInRange(l,"CR1","R1");if(c.isInRange){i.applyNearRight(l,c.percent,r);continue}const d=t.isSlideInRange(l,"R1","R+");d.isInRange?i.applyFarRight(l,d.percent,r):i.applyHidden(l,r)}let n=0;for(let e=0,t=s.length;e<t;e++){const t=s[e];n+=t.rightWidthTrimmed||0,t.renderPosition-=n}let a=0;for(let e=s.length-1;e>=0;e--){const t=s[e];a+=t.leftWidthTrimmed||0,t.renderPosition+=a,t.style.transform=`translateX(${t.renderPosition}px) ${t._scaleTransform||""}`}}destroy(){super.destroy();const e=this.ctx.store.getSlides()||[];for(let t=0;t<e.length;t++){const i=e[t];i&&i.style&&(i.style.transform="",i.style.opacity="",i.style.transition="",i.style.transformOrigin="",i.style.filter="")}}}return void 0!==e.Tarot&&e.Tarot.registerEffect(SpotlightEffect),SpotlightEffect}));
