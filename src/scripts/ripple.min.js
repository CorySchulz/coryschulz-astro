/*!
 ████████╗ █████╗ ██████╗  ██████╗ ████████╗
 ╚══██╔══╝██╔══██╗██╔══██╗██╔═══██╗╚══██╔══╝
    ██║   ███████║██████╔╝██║   ██║   ██║   
    ██║   ██╔══██║██╔══██╗██║   ██║   ██║   
    ██║   ██║  ██║██║  ██║╚██████╔╝   ██║   
    ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝    ╚═╝   

   Tarot Carousel v0.1.0 - beta
   A highly customizable carousel with beautiful, physics-driven animations
   Copyright 2025 Magic Spells LLC

   This software is source-available but not open source.
   See LICENSES for usage tiers and commercial terms.

   Licensed under:
      - Magic Spells Non-Commercial License (free for personal use and non-revenue projects)
      - Magic Spells Commercial License (for commercial use by entities under $1M revenue)
      - Magic Spells Enterprise License (for all use by entities with $1M+ revenue)

     Author: Cory Schulz
    Website: https://www.magicspells.io/tarot
       Repo: https://github.com/magic-spells/tarot
     Issues: https://github.com/magic-spells/tarot/issues
   Licenses: https://www.magicspells.io/licenses
*/
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("@magic-spells/tarot")):"function"==typeof define&&define.amd?define(["@magic-spells/tarot"],e):(t="undefined"!=typeof globalThis?globalThis:t||self).RippleEffect=e(t.Tarot)}(this,(function(t){"use strict";class RippleWindow{#t=0;#e=0;constructor(t,e){this.ctx=t,this.effect=e}init(){this.reInit()}reInit(){const t=this;t.options=t.ctx.store.getOptions();const e=t.ctx.store.getWidths();t.viewportWidth=e.viewport,t.gapWidth=e.gap,t.slideWidth=e.slide,t.slideAndGapWidth=e.slideAndGap,t.trackStartPos=e.paddingLeft,t.trackEndPos=e.viewport-e.track+e.gap-e.paddingRight}setMaxValue(t){this.#e=t}addAmount(t,e=0){const i=this;if(!i.options.loop){if(e>i.trackStartPos)return;if(e<i.trackEndPos)return}return!i.options.loop&&t>0&&e>-1*i.slideWidth||!i.options.loop&&t<0&&e<i.trackEndPos+i.slideAndGapWidth?i.#t-=t:i.#t+=t,i.#t<0?i.#t=0:i.#t>i.#e&&(i.#t=i.#e),i.#t}getPercent(){return this.#e>0?this.#t/this.#e:0}snapToValue(t,e){const i=this;if(0===i.#t||i.#t===i.#e)return;const n=1.25*Math.abs(t);i.#t>i.#e/2?i.addAmount(n,e):i.addAmount(-n,e)}destroy(){const t=this;t.ctx=null,t.effect=null,t.handlers=null}}class TransformRegion{constructor(t){const e=this,{name:i,color:n,property:r}=t;e.enabled=!0,e.name=i,e.property=r}updateOptions({startPos:t,endPos:e,startValue:i,endValue:n,enabled:r=!0}){Object.assign(this,{enabled:r,startPos:t,endPos:e,startValue:i,endValue:n})}applyTransform(t,e,i){const n=this;if(!n.enabled||0===e)return;function r(t){return Math.round(2*t)/2}const s=r((i*=-1)+n.startPos),o=r(i+n.endPos),d=r(t.centerPoint||0);let l=0;if(s>o){if(d>=o&&d<=s){l=(d-o)/(s-o)}}else if(d>=s&&d<o){l=1-(d-s)/(o-s)}if(l<=0)return;const a=l*(n.startValue-n.endValue),p=e*(n.endValue+a);t[n.property]+=p}destroy(){const t=this;t.enabled=!1,t.name=null,t.property=null,t.startPos=null,t.endPos=null,t.startValue=null,t.endValue=null}}class RippleTransforms{constructor(t){const e=this;e.ctx=t,e.paddingLeftWidth=0,e.slideMinWidth=0,e.handlers={windowResize:()=>e.reInit(),optionsChanged:()=>e.reInit()},e.leftEndToMin=new TransformRegion({property:"leftWidthTrimmed"}),e.leftMinToSquished=new TransformRegion({property:"leftWidthTrimmed"}),e.leftSquishedToFull=new TransformRegion({property:"leftWidthTrimmed"}),e.leftFullToMin=new TransformRegion({property:"leftWidthTrimmed"}),e.leftFullToMinEnd=new TransformRegion({property:"leftWidthTrimmed"}),e.rightEndToMin=new TransformRegion({name:"right width end",property:"rightWidthTrimmed"}),e.rightMinToSquished=new TransformRegion({property:"rightWidthTrimmed"}),e.rightSquishedToFull=new TransformRegion({property:"rightWidthTrimmed"}),e.rightFullToMin=new TransformRegion({property:"rightWidthTrimmed"}),e.rightFullToMinEnd=new TransformRegion({property:"rightWidthTrimmed"})}init(){this.bindEvents(),this.reInit()}reInit(){const t=this,e=t.ctx.store.getWidths();t.viewportWidth=e.viewport,t.paddingLeftWidth=e.paddingLeft,t.paddingRightWidth=e.paddingRight,t.slideWidth=e.slide,t.gapWidth=e.gap,t.slideMinWidth=e.slideMin,t.trackWidth=e.track,t.shiftAmount=e.slideMin+e.gap,t.calculateTransformPoints()}bindEvents(){const t=this;t.ctx.emitter.on(t.ctx.events.window.resize,t.handlers.windowResize),t.ctx.emitter.on(t.ctx.events.store.optionsChanged,t.handlers.optionsChanged)}calculateTransformPoints(){const t=this,e=t.slideWidth/2,i=t.slideWidth,n=t.slideWidth+t.gapWidth,r=t.slideMinWidth,s=-1*(i-r),o=-1*(t.gapWidth+r),d=e+t.paddingLeftWidth,l=d-n,a=d-i+r,p=d+n;t.leftEndToMin.updateOptions({startPos:l-t.trackWidth,endPos:l,startValue:s,endValue:s}),t.leftMinToSquished.updateOptions({startPos:l,endPos:d,startValue:s,endValue:o}),t.leftSquishedToFull.updateOptions({startPos:d,endPos:p,startValue:o,endValue:0}),t.leftFullToMin.updateOptions({startPos:a,endPos:d,startValue:s,endValue:0}),t.leftFullToMinEnd.updateOptions({startPos:a-t.trackWidth,endPos:a,startValue:s,endValue:s});const h=t.viewportWidth-e-t.paddingRightWidth,u=h-n,f=h+n,m=f+t.trackWidth,T=h+i-r;t.shiftAmount,t.rightSquishedToFull.updateOptions({startPos:h,endPos:u,startValue:o,endValue:0}),t.rightMinToSquished.updateOptions({startPos:f,endPos:h,startValue:s,endValue:o}),t.rightEndToMin.updateOptions({startPos:m,endPos:f,startValue:s,endValue:s}),t.rightFullToMin.updateOptions({startPos:T,endPos:h,startValue:s,endValue:0}),t.rightFullToMinEnd.updateOptions({startPos:T+t.trackWidth,endPos:T,startValue:s,endValue:s})}applyTransforms(t,e,i,n){const r=this;r.leftEndToMin.applyTransform(t,i,e),r.leftMinToSquished.applyTransform(t,i,e),r.leftSquishedToFull.applyTransform(t,i,e),r.leftFullToMin.applyTransform(t,1-i,e),r.leftFullToMinEnd.applyTransform(t,1-i,e),r.rightEndToMin.applyTransform(t,1-i,e),r.rightMinToSquished.applyTransform(t,1-i,e),r.rightSquishedToFull.applyTransform(t,1-i,e),r.rightFullToMin.applyTransform(t,i,e),r.rightFullToMinEnd.applyTransform(t,i,e),t.leftWidthTrimmed<0&&(t.leftWidthTrimmed=Math.abs(t.leftWidthTrimmed)),t.rightWidthTrimmed<0&&(t.rightWidthTrimmed=Math.abs(t.rightWidthTrimmed))}destroy(){const t=this;t.ctx.emitter.off(t.ctx.events.window.resize,t.handlers.windowResize),t.ctx.emitter.off(t.ctx.events.store.optionsChanged,t.handlers.optionsChanged),t.leftEndToMin?.destroy(),t.leftMinToSquished?.destroy(),t.leftSquishedToFull?.destroy(),t.leftFullToMin?.destroy(),t.leftFullToMinEnd?.destroy(),t.rightEndToMin?.destroy(),t.rightMinToSquished?.destroy(),t.rightSquishedToFull?.destroy(),t.rightFullToMin?.destroy(),t.rightFullToMinEnd?.destroy(),t.ctx=null,t.handlers=null}}class RippleEffect extends t.TarotEffect{static effectName="ripple";static rules={min_slideWidth:1,max_slideWidth:1/0,min_slidesPerView:1,max_slidesPerView:1/0,loopBuffer:{left:2,right:2}};constructor(t){super(t);const e=this;e.ctx=t,e.rippleWindow=new RippleWindow(t,e),e.rippleTransforms=new RippleTransforms(t,e),e.init()}init(){this.rippleWindow.init(),this.rippleTransforms.init()}reInit(){this.rippleWindow.reInit(),this.rippleTransforms.reInit()}render(t,e){const i=this,{slides:n,widths:r,animation:s}=t;i.rippleWindow.setMaxValue(r.slide-r.slideMin),i.renderTrackWidth(r.track),i.renderTrackPosition(s),i.renderSlideWidth(r.slide);const o=s.trackPosition,d=s.trackDelta||0,l=s.type||"jump",a=s.progress||1;("animate"===l||"drag"===l)&&a<=1&&i.rippleWindow.addAmount(d,o),("settle"===l||"animate"===l&&a>.75)&&i.rippleWindow.snapToValue(d,o);const p=i.rippleWindow.getPercent();let h,u=0;for(let e=0,s=n.length;e<s;++e){h=n[e],h.rightWidthTrimmed=0,h.leftWidthTrimmed=0,i.rippleTransforms.applyTransforms(h,o,p,t);const s=r.slide-h.rightWidthTrimmed-h.leftWidthTrimmed;h.style.transition="none",h.style.width=`${s}px`,h.renderPosition=h.trackPosition-u,u+=h.rightWidthTrimmed}let f=0;for(let t=n.length-1;t>=0;--t)h=n[t],f+=h.leftWidthTrimmed,h.renderPosition+=f,h.style.transform=`translateX(${h.renderPosition}px)`}destroy(){super.destroy();const t=this;t.rippleWindow?.destroy(),t.rippleTransforms?.destroy();const e=t.ctx.store.getSlides()||[];for(let t=0,i=e.length;t<i;++t){const i=e[t];i&&i.style&&(i.removeAttribute("aria-hidden"),i.style.width="",i.style.transform="",i.style.transition="")}t.rippleWindow=null,t.rippleTransforms=null}}return void 0!==t.Tarot&&t.Tarot.registerEffect(RippleEffect),RippleEffect}));
